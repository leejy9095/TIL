상당수의 프로젝트들이 프로젝트들은 전부 객체지향을 살려 디자인패턴을 도입하고
객체들간의 역할을 분리하여 객체들간의 협력으로 문제를 해결하는 식의 코딩을 진행하진 않았다

MVC패턴으로 개발한답시고 JSP, Controller, Model은 구분했지만 Service 클래스의 한 메서드 내에서 모든 비즈니스 로직이 진행되는 transaction script 형식의 코딩을 진행했다. 잘 생각해보면 자바는 객체지향언어라는 장점이 있다고 누누히 배워왔지만 정작 실제 현장에서는 C로 함수짜듯 절차지향적 코딩을 해왔다는 점이다. 사실상 우리에게 필요한건 Service 클래스내의 비즈니스로직을 처리하는 1개의 메서드일 뿐이고 그럼에도 불구하고 굳이 Service를 클래스로 만들고 객체를 생성해서 처리하는 이유는 그저 프로젝트에 도입된 언어가 자바이고, 자바는 메서드를 가지려면 무조건 클래스가 있어야했기때문인 것이다. 그렇게 개발을 하다보니 추가적인 요구사항, 혹은 수정사항이 들어오면 이 코드를 확장하여 개발하는것보다는 단순히 그 메서드에 if문을 추가하고, 혹은 소스 일부분을 주석처리하고 새로운 코드로 채우는 리팩토링이 절실한 코드였던 것이다.

MVC 패턴에서 Service Model 의 역할
MVC 패턴의 핵심은 View는 자신이 요청할 Controller만 알고있으면 되고, Controller는 화면에서 넘어오는 매개변수들을 이용해 Service 객체를 호출하는 역할을 한다. Service 는 불필요하게 Http 통신을 위한 HttpServlet을 상속 받을 필요도 없는 순수한 자바 객체로 구성된다(그렇기에 Service 에 request나 response와 같은 객체를 매개변수로 받아선 안된다. 그걸 사용해야하는 작업은 컨트롤러에서 해야한다.). 그렇기에 자신을 어떤 컨트롤러가 호출하든 상관없이기반이 아니라 추후 native app 으로 view단이 변경되더라도 필요한 매개변수만 준다면 자신의 비즈니스로직을 처리하게된다. 즉 모듈화를 통해 어디서든 재사용이 가능한 클래스파일이라는 뜻이다. 단순 Web service는 view에 종속적인 코드가 없기때문에 그대로 재사용 할 수 있어야 한다. 그리고 추가적인 요청사항이 들어오면 기존 소스를 수정하는게 아니라 기존 service 인터페이스를 구현한 다른 클래스를 구현해 그 객체를 사용하게끔 하는것이다. OCP에 입각한 변화에는 닫혀있고 확장에는 열려있는 구조로 만들어야한다는 것이다.

출처: http://multifrontgarden.tistory.com/97 [우리집앞마당]

@@@나중에 추가하기
